# 통신 및 데이터 규약

<br>

## 이벤트 기반 데이터 규약

데이터 규약은 주고받을 데이터의 포맷과 생성 로직을 정의한다. <br>
잘 정의된 데이터 규약에는 데이터 정의(필드, 타입, 자료구조 등)과 생산한 이유, 두 가지 요소가 포함된다.

데이터 정의를 변경할 때는 컨슈머가 사용중인 필드를 삭제/변경하지 않아야 한다. <br>
트리거 로직도 마찬가지이다. 트리거 로직을 바꾸면 원래 이벤트 정의에 담겨진 의미가 깨지는 경우가 많아서, 데이터 정의를 변경하는게 더 일반적이다.

### 명시적인 스키마를 규약으로 활용

데이터 규약을 강제하여 일관성을 유지하는 가장 좋은 방법은 이벤트마다 스키마를 정의하는 것이다. <br>
프로듀서는 데이터 정의와 트리거 로직이 상술된 스키마를 명시적으로 정의하여, 동일한 타입의 이벤트는 모두 해당 포맷을 따르게 된다. <br>
이로써 프로듀서는 미래의 모든 컨슈머에게 이벤트 포맷을 전달하고, 컨슈머는 스키마화 데이터를 받아 적용할 마이크로서비스 비즈니스 로직을 구현할 수 있게 된다.

### 중대한 스키마 변경

도메인 모델을 바꿔야 하는 비즈니스 요건의 큰 변화같은 원인으로 스키마 변경이 불가피한 경우가 있다. <br>
이벤트를 생산하는 서비스는 새 스키마로 쉽게 갈아끼울 수 있지만, 컨슈머는 많은 영향을 받기 때문에 신중하게 살펴야 한다.

<br>

## 이벤트 설계

이벤트 정의를 생성할 때 반드시 피해야 할 안티패턴이 있다. <br>
이벤트 기반 마이크로서비스로 작동되는 아키텍처 수가 늘어날수록 이벤트 정의도 많아진다.

### 오직 진실만을 말할지어다

잘 정의된 이벤트는 단순히 뭔가가 일어났음을 전하는 메시지가 아니라, 그 이벤트가 발생한 동안의 모든 일들을 빠짐없이 기술한다. <br>
이 출력 이벤트를 단일 진실 공급원으로 간주해서, 컨슈머가 소비할 불변의 팩트로 기록해야 한다.

### 스트림당 이벤트 정의는 하나만 사용

이벤트 스트림에는 하나의 논리적 이벤트를 나타내는 이벤트가 포함되어야 한다. <br>
종류가 다른 이벤트들을 이벤트 스트림에 섞어넣으면, 이벤트 실체와 정체성에 혼란을 줄 수 있으므로 바람직하지 않다.

### 가장 좁은 범위의 데이터 타입 사용

이벤트 데이터 타입은 가장 범위가 좁은 것을 사용해야 한다.

- 문자열을 이용해 숫자 값을 저장
- 정수를 불리언으로 사용
- 문자열을 enum으로 사용

위와 같은 사례들은 피해야 한다.

### 이벤트는 하나의 목적만 갖도록

이벤트 정의에 타입 필드를 추가해서 하위 속성을 따로 두려고 하는 것은 안티패턴 중 하나이다. <br>
보통 **비슷하지만 다른 데이터**를 처리하려고 이렇게 하는 경우가 많지만, 개발자가 이벤트를 다목적으로 사용하려고 오해한 결과이다.

각 타입 매개변수값은 기술적 표현형은 동일하지만, 비즈니스 의미는 근본적으로 다르다. <br>
그 의미도 시간이 지나면서 계속 바뀌고 이벤트가 커버하는 영역도 조금씩 달라진다. <br>
타입에 종속된 정보를 추적하고자 새 매개변수를 추가하는 경우도 있고, 아예 별도의 매개변수가 필요한 타입도 있을 것이다. <br>
결국 이벤트 스키마만 같고, 전혀 다른 이벤트가 공존하기 때문에, 나중에는 이벤트가 무슨 의미인지 짐작조차 어려워질 수 있다.

부가적인 필드 타입이 추가된 경우, 컨슈머는 자기가 관심있는 데이터만 가져와야 한다. <br>
컨슈머가 별의별 타입의 의미를 다 이해할 수는 없으니, 처리를 잘못하거나 논리적으로 틀린 코드를 실행할 위험도 있다. <br>
따라서 컨슈머는 자기와 상관없는 이벤트를 제거하는 부가적인 처리 로직을 반드시 수행해야 한다.

#### ex) 이벤트 정의 오버로딩

사용자가 도서를 열람하고 영화를 감상할 수 있는 웹사이트가 있다고 하자. <br>
사용자가 책장을 넘기거나 영화를 보기 시작하면, 백엔드 서비스는 이 액션을 나타내기 위해 ProductEngagement라는 이벤트를 이벤트 스트림에 발행한다.

```
TypeEnum: Book, Movie
ActionEnum: Click

ProductEngagement {
    productId: Long,
    productType, TypeEnum,
    actionType, ActionEnum
}
```

그런데 영화를 보기 전, 어떤 사용자가 영화 예고편을 보았는지 추적하고 싶다는 비즈니스 요건이 등장했다.

```
ProductEngagement {
    productId: Long,
    productType: TypeEnum,
    actionType: ActionEnum,
    // type=Movie인 이벤트에만 적용
    watchedPreview: {null, Boolean}
}
```

그런데 또 다른 비즈니스 요건이 생겼다. <br>
어느 사용자가 도서를 읽다가 책갈피를 했는지, 몇 쪽에서 갈무리를 했는지도 추적하고 싶다. <br>
그러나 ProductEngagement 이벤트는 단일 구조 형태라, Bookmark라는 새로운 액션 엔티티를 추가하고 nullable 필드 PageId를 추가할 수 밖에 없다.

```
TypeEnum: Book, Movie
ActionEnum: Click

ProductEngagement {
    productId: Long,
    productType, TypeEnum,
    actionType, ActionEnum,
    // type=Movie인 이벤트에만 적용
    watchedPreview: {null, Boolean}
    // productType=Book,actionType=Bookmark인 이벤트에만 적용
    pageId: {null, Int}
}
```

<br>

이런 다용도 스키마는 비즈니스 요건이 조금만 달라져도 엄청나게 복잡해진다. <br>
단일 책임 원칙에 따라 다음과 같이 스키마를 나누면 관리하기가 수월해진다.

```
MovieClick {
    movieId: Long,
    watchedPreview: Boolean
}

BookClick {
    bookId: Long
}

BookBookmark {
    bookId: Long,
    pageId: Int
}
```

스트림 : 이벤트 정의 = 1 : 1 원칙을 준수한다면 이벤트 타입이 새로 생길때마다 새로운 스트림이 생성된다. <br>
컨슈머는 한 가지 목적만 가진 안정적인 이벤트 정의 덕분에 안전하게 이벤트를 처리할 수 있다.

### 이벤트 크기 최소화

이벤트는 크기가 작고, 잘 정의되어 있고, 쉽게 처리할 수 있어야 좋지만 <br>
때로는 많은 콘텍스트 정보가 담긴 덩치 큰 이벤트도 발생할 수 있다.

몸집이 큰 이벤트를 설계할때 몇 가지 고려할 부분이 있다. <br>
우선 데이터가 해당 이벤트와 직접 관련이 있는지 확인한다. <br>
모든 데이터가 다 직접 연관되어 있다면, 서비스가 하는 일이 너무 많지는 않은지 검토한다.

### 이벤트를 세마포어나 시그널로 사용하지 않는다.

이런 이벤트는 어떤 결과의 단일 진실 공급원이 아닌, 그냥 뭔가가 일어났음을 알릴 뿐이다.

어떤 작업을 완료했음을 나타내는 이벤트를 출력하는 시스템이 있다고 했을 때, <br>
이 이벤트는 작업이 완료됐다는 사실은 알려주지만, 그 안에 작업 결과가 없기 때문에 이벤트를 제대로 소비하려면 완료된 작업 정보가 있는 곳을 찾아야 한다. <br>
이렇게 데이터 조각 하나에 진실 공급원이 2개 생기게 되면, 일관성에 문제가 생긴다.



















