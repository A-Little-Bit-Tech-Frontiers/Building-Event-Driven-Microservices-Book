## 1. 이벤트 기반 데이터 규약

이벤트 기반 시스템에서 이벤트는 무슨 일이 일어났고 그 이유는 무엇인지 정확하게 기술하는 메시지이자, 통신의 기본 단위이다. **이벤트는 사실 진술서**로서 시스템에서 발생한 다른 이벤트와 조합하여 발생한 사건에 관한 완전한 이력이 된다.
잘 정의된 데이터 규약이 포함하고 있는 요소
- **1. 데이터 정의, 즉 생산할 것들(e.g. 필드, 타입, 그밖의 다양한 자료구조)**
- **2. 트리거 로직, 즉 생산한 이유(e.g. 이벤트 생성을 일으킨 특정 비즈니스 로직)**

비즈니스 요건이 진화할수록 데이터 정의 및 트리거 로직도 달라질 수 있다.

**데이터 정의를 변경할 때는 다운스트림 컨슈머가 사용 중인 필드를 삭제/변경하지 않도록 주의**해야 한다. 
트리거 로직도 마찬가지이다. **트리거 로직을 바꾸면 원래 이벤트 정의에 담겨진 의미가 깨지는 경우가 많기 때문에 데이터 정의를 변경하는 게 더 일반적이다.**


### 1.1 명시적인 스키마를 규약으로 활용  
데이터 규약을 강제하여 일관성을 유지하는 가장 좋은 방법은 이벤트마다 스키마를 정의하는 것이다. 
**프로듀서는 데이터 정의와 트리거 로직이 상술된 스키마를 명시적으로 정의**하여 동일한 타입의 이벤트는 모두 해당 포맷을 따르게 한다.  
-> 프로듀서는 미래의 모든 컨슈머에게 이벤트 포맷을 전달하고 컨슈머는 스키마화 데이터를 받아 적용할 마이크로서비스 비즈니스 로직을 명확하게 구현할 수 있다.

### 1.2 스키마 정의 주석
스키마 정의에서 통합된 주석과 메타데이터는 이벤트 의미를 제대로 전달하기 위해 꼭 필요하다. **이벤트 생산/소비에 관한 지식은 가능한 한 이벤트 정의와 가깝게 붙어 있는게 좋다.**  

### 1.3 완전한 스키마 진화
업무가 변경되면 보통 새 필드를 추가하고 옛 필드를 deprecated 표시를 하거나, 필드 범위를 확장하는 등의 작업이 필요하다.  스키마 진화 없이는 서비스 업데이트 비용이 너무 비싸진다.

- **정방향 호환성**  
  새 스키마로 생성한 데이터를 마치 옛 스키마로 생성한 것처럼 읽을 수 있다.
  
- **역방향 호환성**  
  **옛 스키마로 생성한 데이터를 새 스키마로 생성한 것처럼 읽을 수 있다.** 따라서 데이터 컨슈머는 새 스키마로 옛 데이터를 읽을 수 있다. 역방향 호환성은 아래와 같은 상황에 매우 유용하다.
  - 새 스키마가 미리 정의되어 있으면 프로듀서가 릴리스하기 이전에도 컨슈머가 자신의 업데이트를 릴리스할 수 있다.
  - 옛 스키마로 생성된 이벤트 스트림 데이터를 컨슈머 애플리케이션이 재처리해야 한다. 스키마 진화 덕분에 컨슈머는 이런 데이터도 자신이 익숙한 버전으로 해석할 수 있다. 역방향 호환성이 없으면 컨슈머는 최신 포맷의 메시지만 읽을 수 있는 것이다.


- **양방향 호환성**  
  정방향 호환성과 역방향 호환성의 조합이야말로 가장 강력한 보증 수표이다.


## 2. 이벤트 설계

### 오직 진실만을 말할지어다
**잘 정의된 이벤트는 단순히 “뭔가”가 일어났음을 전하는 메시지가 아니라 그 이벤트가 발생한 동안의 “모든 일들”을 빠짐없이 기술한다.**  
이 출력 이벤트를 **단일 진실 공급원**으로 간주해서 다운스트림 컨슈머가 소비할 불변의 팩트로 기록해야 한다.  
즉, 실제로 일어난 사건에 대해 총체적인 권위를 인정받은 기록물이기 때문에 컨슈머는 그 이벤트가 발생했다는 사실을 다른 데이터 출처를 통해 확인할 필요가 없다.


### 스트림당 이벤트 정의는 하나만 사용
종류가 다른 이벤트들은 이벤트 스트림에 섞어 넣으면 이벤트 실체와 스트림 정체성에 혼란을 줄 수 있으므로 바람직하지 않다. 

### 가장 좁은 범위의 데이터 타입 사용
**이벤트 데이터의 타입은 가장 좁은 범위의 것을 사용**해야 한다. 그래야 코드 생성기, 타입 체크, 직렬화 단위 테스트를 이용해 데이터 경계를 체크할 수 있다. 실전해서 피해야 할 몇 가지 사례들을 통해 왜 그래야 하는지 알아보자.

- **문자열을 이용해 숫자 값을 저장한 이벤트**
    
    컨슈머가 문자열을 파싱해서 숫자 값으로 변환할 경우, null이나 공백이 전달되면 파싱에러가 발생한다.
    
- **정수를 Boolean으로 사용**
    
    0과 1은 각각 거짓과 참을 나타낸다고 하자. -1은 어떻게 할 것인가?
    
- **문자열을 enum으로 사용**
    
  프로듀서는 자신이 발행한 값이 컨슈머가 수용 가능한 enum 타입에 있음을 보장해야 한다. 오탈자와 부정확한 값도 끼어들게 마련이다.
  컨슈머는 자신이 관심 있는 필드의 유효값이 어느 범위에 있는지 알아야 하고 스키마 주석에 명시되어 있지 않는 한 프로듀서측과 사전 협의를 해야만 한다.

### 이벤트는 하나의 목적만 갖도록
이벤트 정의에 타입 필드를 추가해서 하위 속성을 따로 두려고 하는 것은 흔한 안티패턴 중 하나이다.  
보통 “비슷하지만 다른” 데이터를 처리하려고 이렇게 하는 경우가 많지만, 개발자가 이벤트를 다목적으로 사용하려고 오해한 결과이다. 이벤트에 타입 매개변수까지 얹는 모양새는 결코 좋아보이지 않는다.  
**스트림과 이벤트 정의는 1:1 관계여야 한다.** 이 원칙을 준수하면, 이벤트 타입이 새로 생길 때마다 새로운 스트림이 생성된다.
이벤트 정의는 시간이 지나도 표류할 일이 없고 트리거 로직은 바뀌지 않으며, 컨슈머는 한 가지 목적만 가진 안정적인 이벤트 정의 덕분에 안전하게 이벤트를 처리할 수 있을 것이다.

### 이벤트를 세마포어나 시그널로 사용하지 않는다
이벤트를 세마포어나 시그널로 사용하지 말아야 한다. **이런 이벤트는 어떤 결과의 단일 진실 공급원이 아닌, 그냥 뭔가가 일어났음을 알릴 뿐이다.**
