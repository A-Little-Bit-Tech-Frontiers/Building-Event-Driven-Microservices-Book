# 3. 통신 및 데이터 규약

## 이벤트 기반 데이터 규약

**통신의 난제는 메시지 수신자가 생산자의 콘텐츠와 의미를 정확하게 되살리도록 보장하는 일이다.**

이벤트 기반 마이크로서비스에서는 위의 문제를 해결하기 위해, 이벤트 기반 데이터 규약을 이용해야 한다.

규약에 필요한 다음의 정보들은 반드시 명시적인 스키마를 통해 포맷에 맞추어 생산되어야 명확하게 비즈니스 로직을 구현할 수 있다.

- 규약에 필요한 정보
    1. 데이터 정의
    2. 생산할 데이터와 트리거 로직
    3. 생산한 이유
- 스키마를 설계할 때 고려할 것들
    1. 스키마 정의 주석 달기
        1. 주석은 특별한 기능적 역할에 영향을 미치지는 않지만, 이벤트가 생성된 정확한 이유를 파악하고 특정 필드의 구체적인 형식을 알 수 있는 등 컨슈머가 메시지의 의미를 오해하지 않도록 하는 역할을 한다.
    2. **스키마 진화**
        1. 서비스가 발전하면서 프로듀서는 요건에 따라 스키마를 업데이트 할 수 있다. 이때 스키마 포맷은 스키마  진화 규칙의 전체 범위를 지원해야 비싼 서비스 업데이트 비용을 줄일 수 있다.
            1. 정방향 호환성 - 프로듀서가 새로 생성한 스키마를 컨슈머는 기존 스키마의 규칙으로 읽을 수 있다.
            2. 역방향 호환성 - 컨슈머는 새 스키마의 규칙에 따라 기존 스키마의 메시지를 문제없이 읽을 수 있다.
            3. 양방향 호환성 - 가장 이상적인 호환성으로, 정-역방향 호환성의 조합이다.
    3. **코드 생성기**
        1. [**Protobuf](https://protobuf.dev/programming-guides/proto3/)(Google)** 같은 코드 생성기는 각 언어에 맞는 클래스, 코드들을 같은 형식으로 정의하고 각 애플리케이션에서 언어에 맞게 deserialize 할 수 있는 도구이다.
        2. 코드 생성기를 도입하면 반드시 유효한 스키마를 컴파일 할 수 있기 때문에 데이터를 잘못 처리할 위험을 줄이는데 효과적이다.
    4. 중대한 스키마 변경 시 주의할 점
        1. 절대로 **하나의 이벤트 스트림에 여러 종류의 이벤트 타입을 부여해서 사용하지 않는다. 이벤트 스트림 오버헤드는 비용이 저렴하기 때문에 논리적으로 완전히 분리해서 처리하도록 하는 것이 중요하다.**

## 이벤트 설계에 필요한 원칙

1. 이벤트 메시지에는 **반드시 일어난 모든 일을 빠짐없이 사실로 기술할 것**
2. 이벤트 스트림 당 이벤트 정의는 하나만 사용한다.
3. 특수한 목적의 데이터 타입(enum, 정수형 불리언 등)을 사용하지 않고, Primitive 한 타입만을 사용해야 한다.
4. 모든 이벤트는 각각 하나의 목적만을 갖도록 해야 한다.
5. 되도록이면, 이벤트의 크기는 최소화 하도록 하는 것이 좋다.
6. 미래의 컨슈머도 스키마의 고려 대상에 포함하기
7. 이벤트를 Signal, Semaphore 등 신호용으로 사용하지 않는다. 이는 진실 공급원이 아닌, 단순한 알림일 뿐이며, 이벤트의 일관성도 깨지게 된다.
