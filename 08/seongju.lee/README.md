다수의 마이크로서비스가 함께 동작해서 더 큰 비즈니스 워크플로를 구성할까?  
이벤트 기반 마이크로서비스 방식으로 접근할 때 조심해야 할 부분과 예상되는 이슈는?  

## 코레오그래피 패턴
코레어그래피 아키텍처(=리액티브 아키텍처)는 **고도로 분리된 마이크로서비스 아키텍처**를 가리키는 용어이다. **마이크로서비스는 업스트림 프로듀서나 후속 다운스트림 컨슈머와는 완전히 독립적**으로, 대기없이 입력 이벤트가 도착하는대로 반응한다.  

이벤트 기반 아키텍처는 컨슈머가 업스트림 워크플로를 중단시키지 않고도 자유롭게 사용할 수 있는 관련 비즈니스 정보의 재사용 가능한 이벤트 스트림을 제공하는 일에 주력한다.

![image](https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/64b65fa3-c9ce-433c-9517-5c7e41b94613)


## 오케스트레이션 패턴
중앙의 마이크로서비스가 하위의 워커 마이크로서비스에게 명령을 내린 뒤 응답을 기다린다. 오케스트레이터 마이크로서비스는 주어진 비즈니스 프로세스의 전체 워크플로 로직을 알고 있으며 워커 마이크로서비스들에게 특정 이벤트를 전달한다.  

오케스트레이터는 명령을 수신한 마이크로서비스가 응답할 때까지 기다렸다가 워크플로 로직에 따라 결과를 처리한다. 이런 점에서 중앙에서 조정하는 서비스가 없는 코레오그래피 워크플로와는 다르다.  

![image](https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/19b23909-a1f0-4789-b00c-3b07125fdad2)

얼핏 보기에 동기식 요청-응답을 통한 워크플로와 비슷해 보이지만, 성능과 안정성의 트레이드오프를 잘 고려해가며 상황에 맞게 적용하는 것이 중요할 것으로 보인다.  

## 코레오그래피 워크플로의 분산 트랜잭션: 사가 패턴

코레오그래피 워크플로의 분산 트랜잭션은 아주 복잡해질 수 있다. 원래 느슨했던 서비스간의 결합이 단단해질 수 있고, 더러는 전혀 관계가 없던 서비스와 강력한 의존 관계가 맺어지게 될 수도 있다.  
사가 패턴은 단순한 분산 트랜잭션, 특히 시간이 지나도 변경될 일이 거의 없는 강력한 워크플로에 잘 맞다.

![image](https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/b893f300-f843-4462-9e5d-5375e8830011)

컨슈머가 출력 트랜잭션 스트림, 실패한 트랜잭션 스트림 둘 다 소비하더라도 진행 중인 트랜잭션, 처리 중 교착된 트랜잭션읫 상태 정보는 얻을 수 없다.  
그래서 (현재 진행 중이거나 교착된 트랜잭션 상태를 추적하기 위해서)각 이벤트 스트림을 구체화하거나 각 마이크로서비스의 내부 상태 API로 표출해야 한다. 코레오그래피 트랜잭션의 워크플로는 비트랜잭션형 워크플로만큼 변경하는 것이 어려울 뿐만 아니라 이전 마이크로서비스가 수행한 변경분을 롤백해야 하는 오버헤드도 가중된다. 

## 오케스트레이터 모델 기반의 분산 트랜잭션

![image](https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/2fe54bdc-a354-4264-a9d8-5257fc083705)

오케스트레이터가 모든 마이크로서비스에 롤백을 명령한다. 또한, 트랜잭션이 롤백된 다음 해당 이벤트를 최종적으로 어떻게 처리할지(재시도, 폐기 등) 결정하는 역할도 한다.  
오케스트레이터 역시 하나의 프로듀서로서 트랜잭션 실패 이벤트를 출력 스트림에 발행해서 다운스트림 컨슈머가 알아서 처리하게 한다. 이런점에서 단일 작성자 원칙을 위배하지 않고 모든 출력을 소비할 수 있는 단일 스트림이 없는 코레오그래피 패턴과 다르다.  

또한 오케스트레이터는 동일한 출력 스트림에서 진행 중인 트랜잭션의 상태를 표출해서 워커 서비스가 결과를 반환하면 트랜잭션 엔티티를 업데이트할 수 있다.  
이렇게 하면 하부 트랜잭션의 상태를 훨씬 더 자세히 들여다볼 수 있어서 스트림 기반의 모니터링이 가능하다. 

