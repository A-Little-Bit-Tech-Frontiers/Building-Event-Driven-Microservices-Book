## 1. 상태 저장소, 이벤트 스트림에서 상태 구체화

- **구체화(된) 상태**
  
    소스 이벤트 스트림의 이벤트를 투영한 것(불변)
    
- **상태 저장소**
  
    서비스가 비즈니스 상태를 저장하는 곳(가변)
    

구체화 상태와 상태 저장소는 모두 상태 저장 마이크로서비스에서 꼭 필요하며 폭넓게 활용되지만 두 용어를 분명하게 구분해야 한다. **구체화 상태는 마이크로서비스에서 공통 비즈니스 엔티티로 사용할 수** 있고, **상태 저장소에는 비즈니스 상태 및 중간 계산 결과를 저장**할 수 있다.  
마이크로서비스를 설계할 때에는 데이터를 어디에 저장할지 잘 생각해야 한다. 상태를 저장/접근하는 방법은 크게 다음 두 가지가 있다.

1. 처리기와 동일한 컨테이너의 메모리나 디스크에 데이터를 내부적으로 저장
2. 처리기 컨테이너 밖에 있는 외부 스토리지 서비스에 네트워크를 통해 데이터를 저장

**상태를 내/외부 어디에 저장할지**는 주로 마이크로서비스의 비즈니스 역할과 기술 요건에 따라 선택한다. 그런데, 그 전에 먼저 **체인지로그의 역할을 고려할 필요가 있다.**



## 2. 체인지로그 이벤트 스트림에 상태 기록

체인지로그는 상태 저장소에 담긴 데이터의 변경 사항을 모두 기록한 것이다. **상태가 보관된 테이블을 각 이벤트 스트림으로 변환하는 테이블-스트림 이원성의 스트림**에 해당한다.  
체인지로그는 마이크로서비스 인스턴스의 외부에 유지되는 영구적인 상태 사본으로써, 아래 그림처럼 **상태를 재구성하거나 이벤트 처리 진행을 체크포인트하는 수단으로 활용**된다.  

<img src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/fb570246-0e49-472c-b7c6-c18264773469" width="70%">

**체인지로그는 여느 스트림처럼 이벤트 브로커에 저장되는 스트림이면서 상태 저장소를 재구성하는 수단**이다. 체인지로그 스트림은 최근 키/값 쌍만 있어도 상태를 재구성할 수 있으므로 컴팩션을 해야한다.
체인지로그는 특히 내부 상태 저장소에서 높은 성능으로 상태를 확장/복구할 수 있다. 확장/복구 결과 새로 생성된 애플리케이션 인스턴스는 자신에게 해당하는 체인지로그 파티션에서 데이터를 로드하기만 하면 된다.  

<img src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/67941526/78d6a60b-0cb2-4efd-9a01-8947dea8fb1d" width="70%">



## 3. 내부 상태 저장소에 상태 구체화
내부 상태 저장소는 마이크로서비스의 비즈니스 로직과 동일한 컨테이너 또는 VM 환경에 함께 둔다. 이 상태 저장소는 마이크로 서비스 인스턴스가 존재할 경우에만 의미가 있고 둘 다 동일한 기반 하드웨어에서 실행된다.   
**각 마이크로서비스 인스턴스는 자신에게 할당된 파티션의 이벤트를 구체화하고 상태 저장소 내부에서 각 파티션별 데이터를 논리적으로 분리**한다.   
**구체화 상태는 파티션을 소유한 인스턴스에만 존재하므로 리소스 누수가 생기고 진실 공급원이 쪼개지는 불상사도 막을 수 있다.** 파티션이 새로 할당되면 이벤트 스트림이나 체인지로그의 입력 이벤트를 소비해서 재구성할 수도 있다.   
내부 상태 저장소는 보통 키/값 저장소로 구현하지만 다른 종류의 데이터 저장소도 사용할 수 있다.  
(개인적으로 내부 상태 저장소는 곧 데이터 접근의 효율성이 중요하기 때문에 빠른 엑세스를 고려한 것으로 생각)



## 4. 외부 상태 저장소에 상태 구체화
마이크로서비스끼리 구체화 상태를 공유하는 건 외부 데이터 저장소 개발자들이 다양한 비즈니스에 대응하고자 구체화 데이터 세트를 함께 사용하는 흔한 안티패턴이다. 전혀 상관없는 제품과 특성들이 단단하게 결합될 수 있으니 삼가는 것이 좋다.


## 5. 트랜잭션과 실제로 한 번 처리
### 클라이언트-브로커 트랜잭션 없이 실제로 한 번 처리

클라이언트-브로커 트랜잭션을 지원하지 않는 이벤트 브로커도 실제로 한 번 처리는 가능하지만 더 많은 작업이 필요하고 중복 이벤트에 주의해야 한다.  

**첫째, 업스트림 서비스가 실제로 한 번 처리를 보장할 수 없다면 중복 레코드가 생성될 수 있기 때문에 중복 이벤트를 찾아내 걸러내는 작업이 필요**하다.  
**둘째, 이벤트 처리가 시스템 상태에 한 번만 반영되도록 상태 및 오프셋을 하나의 로컬 트랜잭션으로 업데이트해야 한다.** 그래야 클라이언트는 처리 도중 생성된 내부 상태와 입력 이벤트 스트림의 논리적 맥락의 일관성을 맞출 수 있다.

- 중복 이벤트 생성
  
    중복 이벤트는 프로듀서가 이벤트를 이벤트 스트림에 성공적으로 기록했지만 **쓰기 ACK를 받지 못해 재시도**를 하거나 **해당 컨슈머 그룹의 오프셋을 업데이트하기 이전에 실패**할 때 생성된다.
    
- 중복 이벤트 식별
  
    이벤트를 멱등적으로 생산할 수 없고 이벤트 스트림에 중복 이벤트가 있다면 어떻게든 그 영향도를 줄여야 한다. **중복 이벤트의 해시값이 동일하게 계산되도록 프로듀서가 이벤트마다 고유한 ID를 생성하는 것이다.**
      
    **ID의 카디널리티가 아주 높은 요소들로 구성되면 좋다. 즉, ID가 중복될 가능성이 거의 없어야 한다. 중복제거 ID는 이벤트와 함께 생성하거나 컨슈머 소비 시점에 만들 수 있는데, 모든 컨슈머에게 배포하기에는 전자가 더 낫다.**
    
- 중복 방지
    
    실제로 한 번 소비하는 컨슈머는 중복 이벤트를 찾아내 폐기하고 멱등적인 작업을 수행하거나 멱등적 프로듀서를 지닌 이벤트 스트림에서 이벤트를 소비해야 한다.
    **하지만 모든 상황에서 멱등적인 작업을 할 수 있는 것은 아니라서 이벤트가 멱등적으로 생산되지 않는 경우에 비즈니스 로직을 중복 이벤트로부터 보호할 대책을 강구해야 한다.** 게다가 각 컨슈머가 이전에 처리한 dedupeID의 상태 저장소를 알아서 관리해야 하므로 비용도 많이 든다.
    이벤트 볼륨이 커지면 저장소가 아주 커지고 애플리케이션이 보호해야 하는 오프셋이나 시간 범위도 커질 수 있다.
