# 상태 저장 스트리밍

## 상태 저장소, 이벤트 스트림에서 상태 구체화

**구체화 상태**는 마이크로서비스에서 공통 비즈니스 엔티티로 사용할 수 있고 <br>
**상태 저장소**에는 비즈니스 상태 및 중간 계산 결과를 저장할 수 있다.

마이크로서비스에서는 데이터를 어디에 저장할지 잘 생각해야 한다. <br>
1. 처리기와 동일한 컨테이너의 메모리나 디스크에 데이터를 내부적으로 저장하거나 <br>
2. 처리기 컨테이너 밖에 있는 외부 스토리지 서비스에 네트워크를 통해 데이터를 저장할 수 있다.

<img width="625" alt="스크린샷 2024-05-29 오후 8 31 38" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/f42b7dcb-d5f2-420f-8e56-6110460f0af9">

## 내부 상태 저장소에 상태 구체화

각 마이크로서비스 인스턴스는 자신에게 할당된 파티션의 이벤트를 구체화하고 상태 저장소 내부에서 각 파티션별 데이터를 논리적으로 분리한다. <br>
구체화 상태는 파티션을 보유한 인스턴스에만 존재하므로 리소스 누수가 생기고 진실 공급원이 쪼개지는 불상사를 막을 수 있다.

## 외부 사태 저장소에 상태 구체화

마이크로서비스의 외부 상태 저장소를 공통 데이터 스토리지 플랫폼에 둘 수도 있지만, 데이터 세트 자체는 모든 마이크로서비스 구현체와 논리적으로 분리되어야 한다. <br>
마이크로서비스끼리 구체화 사태를 공유하는건 외부 데이터 저장소 개발자들이 다양한 비즈니스 니즈에 대응하고자 구체화 데이터 세트를 함께 사용하는 안티패턴이다.

## 트랜잭션과 실제로 한 번 처리

마이크로서비스는 컨슈머 실패, 후속 복구 등으로 인해 동일한 데이터를 여러번 처리하지만 오프셋은 커밋하지 못한 상태로 스트림 시간만 늘리게 되는 경우가 있다. <br>
트랜잭션을 지원하는 이벤트 브로커도 있다. 카프카는 다수의 이벤트를 다수의 개별 이벤트 스트림에 원자적으로 쓸 수 있도록 지원한다. <br>
트랜잭션을 지원하지 않는 이벤트 브로커를 사용한다면, 클라이언트가 **실제로 한 번 처리**하는 로직을 구현해야 한다.

### 클라이언트-브로커 트랜잭션 없이 실제로 한 번 처리

1. 업스트림 서비스가 실제로 한 번 처리를 보장할 수 없다면, 중복 레코드가 생성될 수 있기 때문에 중복 이벤트를 찾아내 걸러내야 한다. 
2. 이벤트 처리가 시스템 상태에 한 번만 반영되도록 상태 및 오프셋을 하나의 로컬 트랜잭션으로 업데이트해야 한다.

> **중복 이벤트 식별** <br>
> 중복 이벤트를 식별하는 한 가지 방법은 해시값이 동일하게 계산되도록 프로듀서가 이벤트마다 고유한 ID를 생성하는 것이다. <br>
> 이 방법은 대규모 데이터 도메인에 있는 이벤트에는 잘 맞지만, 서로 논리적으로 동등한 이벤트에는 잘 안맞는다. <br>
> 다음은 고유한 ID를 생성할 수 있는 몇 가지 예시이다.
> - 출금 계좌, 입금 계좌, 금액, 날짜/시간 등이 자세히 명시된 은행 계좌 이체
> - 제품, 구매자, 날짜/시간, 총 결제 금액, PG 업체 등이 자세히 명시된 전자상거래 주문
> - 배송때문에 차감된 재고, 이벤트마다 (기존의 고유한 데이터 ID를 사용하는) orderId가 있다

> **중복 방지** <br>
> <img width="620" alt="스크린샷 2024-05-29 오후 8 52 33" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/2c70671a-014a-440a-87c3-086f65b79d5b">



























