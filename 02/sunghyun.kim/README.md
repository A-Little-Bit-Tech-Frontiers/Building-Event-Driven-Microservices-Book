# 이벤트 기반 마이크로서비스 기초

<br>

## 토폴로지

### 마이크로서비스 토폴로지

마이크로서비스 토폴로지는 마이크로서비스 내부의 이벤트 기반 토폴로지이다. <br>
변환, 저장, 방출 등 인입된 이벤트에 수행할 데이터 주도 연산을 정의한다.

<img width="561" alt="스크린샷 2024-05-04 오후 4 24 33" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/0bbe7676-b2ed-4a55-9e73-0171985adbd1">


### 비즈니스 토폴로지

비즈니스 토폴로지는 복잡한 비즈니스 로직을 처리하는 마이크로서비스, 이벤트 스트림, api 집합이다. <br>
이는 서비스를 임의로 그룹핑한 것으로, 하나의 팀/부서가 소유한 서비스나 복잡한 비즈니스 기능의 상위 집합을 수행하는 서비스를 나타낸다.

<img width="554" alt="스크린샷 2024-05-04 오후 4 27 10" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/165d4ec3-73aa-4848-8c9b-5ece0432ea92">

<br>

## 이벤트 콘텐츠

이벤트는 발생한 사건의 기록물이다. <br>
이벤트는 로그와 달리 기록물이면서 단일 진실 공급원이다. 발생한 사건을 정확하게 나타내기 위해 필요한 모든 정보를 담아야 한다.

<br>

## 이벤트 구조

이벤트는 보통 key-value로 표현한다. <br>
이벤트의 전체 세부 정보는 value에 보관하고, key는 식별, 라우팅, 같은 key를 가진 이벤트를 집계하는데 사용된다.

### key 없는 이벤트

이는 하나의 사실을 진술한 형태로 나타낸 이벤트이다. <br>
*ex) 전자책 플랫폼 고객이 어떤 도서를 펼쳐보는 것처럼 상품과 상호작용을 했다는 사실을 이벤트로 표현*

### 엔티티 이벤트

엔티티는 유일한 ID가 key로 부여된다. <br>
엔티티 이벤트는 어느 시점의 속성 및 상태를 기술한다. 

### key 있는 이벤트

key를 포함하지만 엔티티를 나타내지는 않는다. <br>
주로 이벤트 스트림의 한 파티션 내에서 데이터 지역성을 보장하기 위해 이벤트 스트림을 파티셔닝하는 용도로 쓰인다. <br>
*ex) key가 ISBN인 이벤트의 스트림을 보면, 어느 사용자가 어떤 도서를 만지작거렸는지 알 수 있다.*

<br>


## 엔티티 이벤트에서 상태를 구체화

엔티티 이벤트 스트림에서 흘러온 엔티티 이벤트를 순서대로 적용하면, 상태 저장 테이블을 구체화할 수 있다. <br>
각 엔티티는 key-value 테이블에 upsert되므로 key별로 가장 최근에 읽은 이벤트를 알 수 있다. <br>
반대로 각 업데이트를 이벤트 스트림에 발행하여 테이블을 엔티티 이벤트의 스트림으로 바꿀수도 있다.

비즈니스 로직을 처리하기 위해 상태를 유지하는 것은 이벤트 기반 아키텍처에서 일반적인 패턴이다. <br>
중요한 정보를 계속 추적하고, 관리하기 위해 이벤트 스트림을 구체화해서 현재 상태를 나타낼 수 있어야 한다.

<br>

## 이벤트 데이터 정의와 스키마

컨슈머가 서비스를 생산하는 프로듀서에게 따로 물어보지 않고 이벤트 콘텐츠와 의미를 해석할 수 있으면 가장 이상적이다. <br>
이렇게 producer/consumer가 원활하게 소통하려면 공통적인 언어가 필요하다.

<br>

## 마이크로서비스를 이벤트 브로커로 강화

이벤트 브로커는 이벤트를 받아 큐 또는 파티션된 이벤트 스트림에 저장하고, 다른 프로세스가 소비할 수 있도록 제공한다. <br>
다수의 분산된 이벤트 브로커가 한 클러스터로 동작하면서, 이벤트 스트림의 생산/소비 플랫폼을 제공한다. <br>
이 모델은 이벤트 기반 체계를 대규모로 운영할 수 있도록 몇 가지 기능을 제공한다.

- 확장성
- 보존성
- 고가용성
- 고성능
- 파티셔닝
- 순서 보장
- 불변성
- 인덱싱
- 무기한 보존
- 재연성

<br>

## 이벤트 브로커 vs 메시지 브로커

**메시지 브로커**를 사용하면 발행/구독 메시지 큐를 통해 네트워크 전체를 통신할 수 있다. <br>
프로듀서가 메시지를 쓰면 컨슈머는 메시지를 받아 처리하고, 메시지가 소비된 것으로 ACK되면 삭제되는 구조이다.

**이벤트 브로커**는 순서대로 쌓은 사실 로그를 제공할 목적으로 설계되었다. <br>
이벤트 브로커는 레코드 장부를 딱 하나만 보관하고, 인덱스를 통해 개별 액세스를 관리하기 때문에 독립적인 여러 컨슈머가 각자 필요한 이벤트를 마응대로 꺼내갈 수 있다. <br>
또 이벤트 브로커는 업무상 필요한 시간동안 이벤트를 보존할 수 있다.
















