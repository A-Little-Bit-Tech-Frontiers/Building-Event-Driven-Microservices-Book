# 2. 이벤트 기반 마이크로서비스 기초

### 토폴로지(Topology)

토폴로지란, 네트워크에서 사용되는 용어로 노드(Node), 링크(Link) 들을 물리적으로 연결해 놓는 방식 혹은 배치를 뜻한다. 각 마이크로서비스는 노드라고 할 수 있으며, **마이크로서비스 토폴로지, 비즈니스 토폴로지** 등으로 분류된다.

- **마이크로서비스 토폴로지**
    - 마이크로서비스 내부에서의 이벤트 기반 토폴로지로, 어떤 이벤트 스트림에서 이벤트를 받아 스토리지에 구체화 하거나, 이벤트를 변환 후 새로운 이벤트로 변환해서 새 이벤트 스트림으로 내보내는 행위를 정의한다.
    
    ```mermaid
    graph TB
    	A[이벤트 스트림 A]
    	B[이벤트 스트림 B]
    
    	subgraph 마이크로서비스 토폴로지
    		C[필터 혹은 변환 및 조인]
    		D[출력 스트림]
        DB[저장소]
    	end
    	
    	A --> DB
        B --> C --> D
        C --> DB
    
    ```
    
- **비즈니스 토폴로지**
    - 마이크로서비스와 이벤트 스트림, API 들의 집합으로 이루어진 토폴로지로, 서비스 노드 간 연결 관계의 형태를 보여준다.
    
    ```mermaid
    graph TB
    	A[이벤트 스트림 A]
    	B[이벤트 스트림 B]
    	C[이벤트 스트림 C]
    	A1[마이크로서비스 1]
    	B1[마이크로서비스 2]
    	C1[마이크로서비스 3]
    	
    	A --> A1
    	A1 --> B
    	B --> B1
    	B --> C1
    	C1 --> C
    ```
    

### 이벤트 컨텐츠와 이벤트 구조

이벤트에 들어갈 컨텐츠는 어떤 것이라도, 비즈니스에서 요구되는 것이라면 가능하다. 이는 이벤트 구조에 따라 달라질 수도 있는데, 중요한 것은 사건을 기록하는 진실 공급원 이라는 점이기 때문에 필요한 모든 정보를 가지고 있어야 한다.

일반적으로 이벤트는 Key : Value 구조로 표현한다. 하지만 형식에 따라 이 구조는 절대적이지 않을 수 있다.

- 키, 값 모두 있는 이벤트 : { PK : PK 에 해당하는 세부 정보 }
- 키 없는 이벤트 : { N/A : 사건을 정의하는 모든 데이터 }
- 키 있는 이벤트 : { PK : Data }
    - 키를 가지고 있긴 하지만, 엔티티의 PK 를 나타내지 않을 수 있다. 주로 이벤트 스트림의 파티션 내에서 데이터 지역성을 보장하기 위해 스트림을 파티셔닝 하기 위한 용도로 사용된다.
- **엔티티 이벤트 *****
    - 유일한 엔티티 데이터의 변화를 기점으로 발생하는 이벤트이다. 키는 유일키, 값은 변경 시점의 엔티티 데이터가 될 수 있다.
    - 이 이벤트가 중요한 이유는, 우선 엔티티는 마이크로서비스간 공유되는 상태로서 참조될 수 있다. 가령 공통적인 인증 서버의 가입자 (User) 엔티티가 있다고 하자. 이 User 는 서비스를 이용하는데 필수적인 요소로, 소유자의 역할을 하기 때문에 많은 관계의 중심이 된다. 그렇기에 이 엔티티의 정보는 여러 서비스에서 참조할 수 있어야 하는데, 그 정보를 어떻게 관리할까? 이에 대한 해답으로 엔티티 이벤트를 사용해서 최신 엔티티의 정보를 “복사” 해서 관리할 수 있는 것이다.

### 엔티티 이벤트로 상태 구체화

테이블-스트림 이원성이란, 이벤트 기반 마이크로서비스에서 상태를 생성하는 매커니즘이다. 상태를 추가/변경/삭제하는 모든 동작은 이벤트 스트림에 최신 상태를 가진 이벤트를 발행해서 업데이트하게 된다.

- Compaction
    - (키 있는 이벤트에 해당) 오래된 이벤트를 스트림에서 제거하여, 키 별로 가장 최근의 이벤트만 집계하여 불변 로그의 크기를 최소화 하는 과정이다. 이때 툼스톤 이벤트 (value = null 인 데이터, null 일 경우 데이터를 삭제하는 명령으로 사용) 또한 모두 제거된다.

### 이벤트 데이터 정의 및 스키마

마이크로서비스 에서는 통신 수단 뿐만 아니라, 서로 데이터를 똑같이 이해할 수 있는 수단이 필요하다. 동기식 요청에서의 API 정의와 비슷하지만, 각 서비스가 상위 스키마 생성기(such as Protobuf, Avro)를 사용해 각자의 언어에 맞는 정형 클래스를 생성하여 사용할 수 있다.

### 단일 작성자 원칙

이벤트 스트림에 배포하는 프로듀서는 반드시 하나의 마이크로서비스 이기 때문에, 이벤트를 역추적하면 결국 공급원은 하나로 귀결된다.

### 이벤트 브로커 vs 메시지 브로커

메시지 브로커는 오래전부터 사용되었다. 메시지를 프로듀서가 발행하면, **단 하나의 컨슈머가 메시지를 소비**하고 삭제하는 구조이기 때문에 이벤트가 보존되지 않아 과정을 재연할 수 없다. 또한, 이벤트가 삭제되지 않으면 큐에 반환되어 다른 컨슈머가 처리할 수도 있기 때문에 순서가 보장되지 않아 예상한 처리 순서가 달라질 수 있다.

이벤트 브로커는 레코드 장부를 하나만 보관하고 인덱스를 통해 개별 인덱스를 관리한다. 그렇기에 메시지의 순서가 보장되고, 불변 사실 로그를 관리하기 때문에 로그의 특정한 위치부터 메시지를 차례로 소비해서 재처리 할 수 있다.

- **이벤트 스트림 소비**
    - [Apache Kafka](https://docs.confluent.io/platform/current/clients/consumer.html) 같은 서비스는 Offset 과 Consumer Group 으로 이벤트 스트림에서 메시지 소비 진행 상황을 추적할 수 있도록 관리한다. 각 컨슈머 그룹에서는 이벤트 스트림 별로 파티셔닝 되어진 파티션을 각 컨슈머 마다 할당한다. 그리고 그 파티션에서 소비한 인덱스를 Offset 으로 설정해서 독립적으로 진행 상황을 파악할 수 있도록 한다.

### 마이크로서비스 관리

- 컨테이너 vs 가상 머신(VM)
    - Docker 같은 컨테이너 방식으로 각 서비스를 격리해서 관리할 수 있다. 컨테이너 방식은 OS 를 공유하기 때문에 해당 OS 의 보안에 문제가 생기면 전체적으로 영향을 받는 구조이기 때문에 보안에 다소 취약하다.
    - VM 을 사용하면 각 머신 별로 OS 가 인스턴스화 되기 때문에 완전한 격리가 가능하다. 발전 중이긴 하지만, 아직도 VM 은 비싼 오버헤드 비용을 감수해야 한다. (시스템 요구 용량, 시동 성능 등)