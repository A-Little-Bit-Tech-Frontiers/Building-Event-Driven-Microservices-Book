## 1. 데이터 해방 패턴
데이터 해방 패턴은 여러 하부 시스템이나 데이터 저장소에 흩어져 있는 데이터를 다른 저장소로 마이그레이션하는 과정이다. (여기서 말하는 다른 저장소는 이벤트 스트림)
**이 이벤트 스트림은 새로운 단일 진실 공급원으로 작용**하여, 모든 데이터 관련 질의(query)와 처리가 이루어지는 곳이 된다.

데이터 해방 프레임워크는 자칫 데이터 접근 안티패턴을 조장할 우려가 있다. 내부 데이터 모델을 외부 시스템에 노출시켜 결합도를 외려 증가하고, EDA의 중요한 이점 중 하나가 흐려지는 것이 가장 일반적인 안티패턴이다.

  
## 2. 쿼리로 데이터 해방

### 2.1 증분 타임스탬프 로딩
이전 쿼리 결과의 최종 타임스탬프 이후에 쌓인 데이터를 쿼리해서 적재한다. `updated_at` 필드를 기준으로 레코드가 가장 마지막에 수정된 시간을 찾아, 이후 레코드만 가져온다.

- 데이터의 일관성: updated_at 타임스탬프를 사용하면 이벤트가 발생한 정확한 순간을 기록할 수 있다.
- 순서보장: 어느 수정이 가장 최근에 이루어졌는지를 판단할 수 있으며, 각 이벤트가 실제로 발생한 순서를 보장하여 시스템이 이벤트를 올바른 순서대로 처리.

### 2.2 자동증가 ID 로딩
선후 관계가 분명한 자동증가 정수 또는 Long 타입 필드가 필요하다. 아웃박스 테이블처럼 불변 레코드가 있는 테이블을 쿼리할 때 자주 사용한다.  


## 3. CDC 로그로 데이터 해방
데이터베이스에서 발생하는 모든 변경사항(생성, 수정, 삭제)을 실시간으로 감지하고 캡처한다. 

## 4. 아웃박스 테이블로 데이터 해방
내부 데이터에 관한 중요한 업데이트가 로우 단위로 삽입된다. CDC 대상으로 표시된 데이터 저장소에서 테이블 레코드가 삽입, 수정, 삭제될 때마다 해당 레코드가 아웃박스 테이블에 발행되는 구조이다.  

데이터 저장소 클라이언트는 내부 테이블의 업데이트, 아웃박스 테이블의 업데이트를 각각 하나의 트랜잭션으로 묶어 처리하고므로 도중 실패하더라도 두 테이블 간 데이터 정합성이 유지된다.
한편, 이와 별도의 애플리케이션 스레드나 프로레스는 아웃박스 테이블을 계속 폴링해서 해당 이벤트 스트림에 데이터를 생산한다. 여기까지 성공하면 아웃박스 테이블의 레코드는 삭제된다. 만약 실패하더라도, 즉 데이터 저장소, 프로듀서/컨슈머, 심지어 이벤트 브로커 중 어느 한곳에 장애가 발생해도
아웃박스 테이블의 레코드는 소실되는 일 없이 보존된다. 즉, 적어도 한 번 이상의 전달을 보장한다.

### 내부 데이터 모델 격리
아웃박스 테이블을 내부 테이블과 1:1 매핑할 필요는 없다. 사실, 아웃박스 테이블의 중요한 장점은 데이터 저장소 클라이언트가 다운스트림 컨슈머에 대해 내부 데이터 모델을 격리할 수 있다는 점이다.
데이터 저장소 클라이언트는 아웃박스 테이블에 퍼블릭 데이터 규약을 잘 반영되도록 삽입 시점에 데이터를 반정규화할 수 있다(이벤트화).
정규화한 raw 이벤트는 아웃박스 테이블에서 각각의 이벤트 스트림으로 소싱되지만 이들 스트림은 내부 데이터 모델 보호 차원에서 다른 부서와 격리된 별도의 프라이빗 네임스페이스에 보관된다.
즉, 반정규화를 통해 내부 데이터 모델의 구조를 이벤트화하는 셈이다.
