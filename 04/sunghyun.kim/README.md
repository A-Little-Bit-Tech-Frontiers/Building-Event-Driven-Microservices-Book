# 기존 시스템에 이벤트 기반 아키텍처 통합

어떤 비즈니스 도메인이건 여러 하위 도메인에 공통적으로 필요한 엔티티와 이벤트가 있다. <br>
예를 들어 전자상거래 소매업자는 제품 정보, 단가, 재고, 이미지를 다양한 경계 콘텍스트에 제공해야 한다. <br>
지불은 한 시스템에서 취합하더라도 유효성은 다른 시스템에서 검증하고, 구매 패턴 분석은 또 다른 시스템에서 하는 방식이다.

새로운 단일 진실 공급원으로서 데이터를 중앙에서 사용한다면 각 시스템은 필요할 때마다 얼마든지 데이터를 소비할 수 있다. <br>
따라서 이벤트 기반 마이크로서비스로 전환하려면, 먼저 이벤트 브로커에 있는 비즈니스 도메인 데이터를 이벤트 스트림으로 소비할 수 있도록 놓아주어야 한다. <br>
이것이 기존 시스템 및 상태 저장소에서 데이터를 소싱하는 **데이터 해방 프로세스**이다.


<br>

## 데이터 해방이란 ?

<img width="466" alt="스크린샷 2024-05-06 오후 2 23 44" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/5187646f-4db4-4b76-8028-1ffab0fc2e7d">

<img width="722" alt="스크린샷 2024-05-06 오후 2 24 52" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/99814d46-1c59-4bec-b8bc-657cd5a74fb3">

데이터 해방은 교차 도메인 데이터 세트를 식별해서 각 이벤트 스트림에 발행하는, 이벤트 기반 아키텍처의 마이그레이션 전략이다. <br>
데이터를 해방하면 단일 진실 공급원을 제공하고, 시스템 간 직접 결합을 방지하는, EDA의 두 가지 중요한 특징이 적용된다.

### 데이터 해방 시 고려사항

데이터 세트와 해방된 데이터 스트림은 완전히 동기화돼야 한다. <br>
해방된 이벤트 스트림은 반드시 똑같이 복제한 소스 테이블의 레플리카로 다시 구체화해야 한다.

이상적인 조건이라면 모든 상태를 이벤트 스트림의 단일 진실 공급원에서 생성, 유지, 관리, 복구할 수 있다. <br>
공유 상태는 빠짐없이 이벤트 브로커에 발행하고 최초로 그 데이터를 생성한 서비스를 비롯해 상태 구체화가 필요한 모든 서비스에서 다시 구체화되어야 한다.

<br>

## 데이터 해방 패턴

#### 쿼리 기반

하부 데이터 저장소를 쿼리해서 데이터를 추출한다. 어떤 종류의 데이터 저장소든 작업이 가능하다.

#### 로그 기반

하부 데이터 구조의 변경 내역을 기록한 붙임 전용 로그를 기준으로 데이터를 추출한다. 데이터 변경 로그를 보관하는 데이터 저장소에서만 가능한 방법이다.

#### 테이블 기반

출력 큐로 사용할 테이블에 데이터를 푸시한다. 다른 스레드나 별도의 프로세스가 테이블을 쿼리해 데이터를 정해진 이벤트 스트림으로 내보낸 뒤 관련 엔티리를 삭제한다. <br>
이 방법은 데이터 저장소가 트랜잭션 및 출력 큐 메커니즘을 모두 지원할 경우 가능하다.

> 세 가지 패턴의 공통점은, 소스 레코드의 최근 업데이트 시간(updated_at) 컬럼을 이용해 이벤트를 타임스탬스 순서대로 생산해야 한다는 점이다. <br>
> 프로듀서가 이벤트를 발행한 시간이 아닌, 이벤트 자체가 발생한 시간이 타임스탬프로 찍힌 이벤트 스트림이 생성된다.

<br>

## 쿼리로 데이터 해방

데이터 저장소를 쿼리한 결과를 관련 이벤트 스트림에 흘려보내는 것이다. <br>
클라이언트는 API, SQL 등을 이용해 데이터 저장소에서 원하는 데이터 세트를 요청한다.

### 장점

- 독립적인 폴링 주기
- 내부 데이터 모델의 격리

### 단점

- updated_at이 필수
- hard delete 추적 불가
- 생산 리소스 낭비
- 데이터 변경때문에 쿼리 성능이 오르락내리락

<br>

## CDC 로그로 데이터 해방

데이터 저장소에 내장된 CDC *(ex. mysql 바이너리 로그)* 기능을 활용하는 것이다. <br>
데이터 저장소 로그는 어마어마하게 커질 가능성이 있고, 따로 장기 보관할 필요는 없기에 처음부터 발생한 변경 기록을 전부 포함하고 있지는 않다. <br>
그래서 데이터 저장소 로그에서 CDC 프로세스를 시작하기 전에 기존 데이터의 스냅샷을 찍어야 한다.

### 장점

- 삭제 추적
- 데이터 저장소 성능에 미치는 영향 최소
- low latency update

### 단점

- 내부 데이터 모델 노출
- 데이터 저장소 외부에서 반정규화

<br>

## 아웃박스 테이블로 데이터 해방

아웃박스 테이블에 데이터 저장소의 내부 데이터에 관한 중요한 업데이트가 로우 단위로 삽입된다. <br>
CDC 대상으로 표시된 데이터 저장소에서 테이블 레코드가 삽입, 수정, 삭제될 때마다 해당 레코드가 아웃박스 테이블에 발행되는 구조이다.

내부 테이블의 업데이트와 아웃박스 테이블의 업데이트는 단일 트랜잭션으로 묶어 트랜잭션 성공 시에만 두 업데이트가 일어난다. <br>
이는 데이터 저장소의 보존성을 활용하여, 외부 이벤트 스트림에 발행 대기 중인 이벤트를 선행 기입 로깅하는 기능을 제공한다.

<img width="751" alt="스크린샷 2024-05-06 오후 2 39 41" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/e2e9bbcd-f24e-4c7f-9e24-88d404ad612e">


### 내부 데이터 모델 격리

아웃박스 테이블을 내부 테이블과 1:1 매핑할 필요는 없다. <br>
아웃박스 테이블의 중요한 장점은 데이터 저장소 클라이언트가 다운 스트림 컨슈머에 대해 내부 데이터 모델을 격리할 수 있다는 점이다. <br>
**내부 데이터 모델을 다운 스트림 컨슈머에게 표출하는 것은 안티패턴이다.**

<img width="761" alt="스크린샷 2024-05-06 오후 2 41 50" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/5ff9ddab-1381-42f5-b967-cfae8b323c41">

### 스키마 호환성 보장

스키마 직렬화, 검증을 캡처 워크플로에 구현할 수 있다. 아웃박스 테이블에 이벤트가 기록되기 전후에 수행하면 좋다. <br>
성공하면 이벤트를 워크플로 다음 단계로 진행하고, 실패하면 원인을 파악하고 데이터 손실을 막기 위해 수작업이 필요하다. <br>
데이터 일관성 측면에서는 아웃박스 테이블에 트랜잭션을 커밋하기 전에 직렬화하는 것이 가장 좋다.

<img width="703" alt="스크린샷 2024-05-06 오후 2 44 01" src="https://github.com/A-Little-Bit-Tech-Frontiers/Building-Event-Driven-Microservices-Book/assets/87420630/424ccea8-0fe2-4678-be58-d057c0cbf835">

<br>












