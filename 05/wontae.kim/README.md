# 5. 이벤트 기반 처리 기본

이벤트 스트림에서 이벤트를 소싱하는 마이크로서비스의 처리 방식에 대해서

### 상태 비저장 토폴로지

마이크로서비스 토폴로지는 컨슈머의 입력으로 이벤트가 들어오면 로직을 처리하고 다시 이벤트로 내보낼 수 있다. 여기서 비즈니스 로직을 수행하기 위한 기능을 선택해야 한다.

1. 변환
    1. 하나의 이벤트를 처리해서 하나 이상의 출력 이벤트를 내는(emit) 과정
2. 스트림 분기 및 병합
    1. 하나의 이벤트로 시작해서 특정한 논리 연산을 적용해서 새로운 스트림으로 출력하는 과정. SQS 의 경우 이벤트 브로커는 아니지만, 정상적인 컨슘에 실패하면 dead-letter-queue 에 보내는 방식을 예로 들 수 있다.
3. **이벤트 스트림 리파티션**
    1. 이벤트 키와 파티셔너 로직을 사용해 파티셔닝 할 수 있다. 리파티션이란 파티션 수, 이벤트 키, 파티셔너 속성을 사용해 새 이벤트 스트림을 생산하는 행위를 말한다. 하지만 리파티션을 하는 경우는 드물다.
4. **이벤트 스트림 코파티션** **
    1. 하나의 이벤트 스트림의 키가 존재하는 이벤트를 다른 이벤트 스트림의 이벤트와 같은 곳에 배치하기 위해 필요한 작업이다. **“같은 키” 를 가지는 이벤트들을 동일한 노드에서 처리하기 위해 중요한 개념이다.**
    2. 이벤트 스트림의 파티션이 다른 이벤트 스트림의 파티션과 스트리밍 조인 하여 새 이벤트 스트림으로 파티셔닝 되는 방식으로 코파티션이 이루어진다.
5. 컨슈머 인스턴스에 파티션 할당
    1. 컨슈머 인스턴스당 파티션을 할당하는 이유는 대용량 데이터를 처리하기 위해 컨슈머 마이크로서비스의 인스턴스를 수평적으로 확장하여 병렬 처리해야 하는데, 이때 각 인스턴스가 컨슈머 그룹을 가지며 오프셋이 각자 독립적이어야 하는데, 이럴 때 파티션을 각 인스턴스가 나눠가지면 병렬적으로 처리할 수 있다.
    2. 코파티션된 파티션을 할당할 때는 하나의 컨슈머 인스턴스에 할당해야 한다. 이는 동일한 노드에서 코파티션에 존재하는 이벤트를 일괄적으로 처리하기 위함이다.
